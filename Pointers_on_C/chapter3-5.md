# 第三章
## 整型
- short int至少16位 long int至少32位，int究竟是16还是32，或是其他，则由编译器设计者决定。
- const是命名常量，初始化之后，值不能改变
- 字符就是小的整型，char型变量的值位于signed char和unsigned char的交集中，这个程序才是可移植的。强制位unsigned char和signed char可能会使效率降低，要获得最大程度地可移植性，又不牺牲效率，就要把char值限制在signed char和unsigned char的交集。
## 浮点型
- long double>=double>=float>>都必须容纳10e-37~10e37之间的任何值
## 指针
## 字符串常量
使用字符串常量的时候都是在使用它的指针，因此不能把一个字符串常量赋给字符数组。要进行更多的操作，建议使用C语言标准库里的函数。
## 声明指针
推荐使用如
```C
int *a;
```
如果这样
```C
int* a;
int* b, c, d;
```
a被声明成指针，b也是，但是c和d是普通的int型。
```C
char *message = "hello world!";
```
hello world赋给message本身，而不是message的指针
## 隐式声明
ANSI C中隐式声明非法，在K&R C中是可用的，默认为整型
```C
int a[10];
int c;
b[10];
f(x)
{
    return x + 1;
}
```
## typedef
对已有类型的重命名
```C
typedef char *ptr_to_char;
```
ptr_to_char作为指向字符的指针类型的新名字
使用typedef而不是#define，#define无法正确处理上面这种指针的情况
## 常量
```c
int const a;
const int a;
```
两种写法都可以。常量无法被修改体现在常量只能在
- 声明时初始化
- 形参被调用时得到实参的值

如果变量的值不会被修改，应该使用const关键字，不仅能够展现你的意图，而且能使错误操作被编译器发现
### 名字常量与字面值常量的区别
名字常量的应用范围更广，如数组的长度，字面值常量只能用于可以使用变量的地方，更改#define也比在代码中找到const量更加容易
## 作用域
* 代码块作用域
    * 嵌套代码块，内层作用域到该代码块尾部即终止
* 文件作用域
* 原型作用域
    * 原型中的参数名不必与函数定义的形参名相同
* 函数作用域
## 链接类型与存储类型
* external - 无论声明多少次，位于多个源文件均表示同一实体，类似public
* internal - 同一个源文件内的所有声明指向同一实体，不同源文件不同实体，类似private
* none - 没有链接属性的标识符总是被当作单独个体

存储类型缺省为自动(auto)
## 引申
- const 与 define 的区别
- 指针与引用的区别
- C语言里的char-能表达什么-有哪些形式-如何实现国际化兼容性
# 第四章
switch-case语句中，case标签知识确定语句列表的进入点而不是划分它们的原因。
## 退出深层循环的方式有两种
- 使用goto语句转到语句标签
- 把循环放到函数里，return语句结束函数也就退出了循环
# 第五章 操作符和表达式
## 移位操作
右移操作分为逻辑移位和算术移位，前者无视符号位，后者则不改变符号位的同时，仅移动符号位之后的数字<br>
>标准说明无符号值执行的所有移位操作都是逻辑移位，但对于有符号值，到底是采用逻辑移位还是算术移位取决于编辑器。

移位值为负的情况是标准未定义的，结果如何取决于编译器

## 赋值操作
```C
char ch;
...
while( ( ch = getchar() ) != EOF ) ...
```
getchar返回的int值被 __截短__ 成char
## 其他
- 优先级
- 左结合/右结合