# 字符串、字符和字节
## 结构
"字符串的内容"+NUL字节，以指针形式访问
## 字符串函数

| 不受限制 | 风险 | 长度受限 | 风险 |
|-------|:-------:|:-----:|------:|
|strcpy | 溢出：覆盖数组后的空间|strncpy|src长度<len:不以NUL字节结尾|
|strcat|溢出|strncat|溢出，但是总是以NUL字节结尾|
|strcmp|返回的值除了0以外由编译器决定，标准仅仅规定，s1>s2返回>0，小于返回|strncmp|同strcmp|
字符串查找
* 查找字符，strchr，返回第一次出现的位置的指针，strrchr，返回最后一次
* 查找字符串，同上，标准库没有实现，需要自己实现。
# 结构和联合
## 结构体
结构变量属于标量类型，可以声明一个指向结构变量的指针变量。
```C
/****************************
**使用typedef和tag声明结构体***
*****************************/
typedef struct SELF_REF3_TAG {
    int        a;
    struct     SELF_REF_TAG *b;
    int        c;
} SELF_REF3;
///////////////////////我加入的
SELF_REF3 bla;
SELF_REF3 *cp = &bla;
cp->a;
```
包含的知识点
* TAG与typedef的选择
* 初始化顺序
* 结构的自引用
* 结构成员的间接访问（->符号）
> 如果你想在多个源文件中使用同一种类型的结构，你应该把标签声明或typedef形式的声明放在一个头文件中。
# 动态内存分配
## 解决的问题
> 如果需要的数组空间不确定，之前学的方法就是让数组尽量的大。这回带来一系列缺点：
> * 这种声明在程序中人为引入了限制，如果需要使用的元素数量超过了声明的长度，它就无法处理这种情况
> * 实际需要的元素数量较少时，数组的绝大部分空间都被浪费了
> * 如果溢出，那么程序需要以一种合理的方式作出响应。
## malloc和free
### 过程
1. malloc接受参数
2. 请求连续内存空间，返回一个类型为void *的指针
3. 如果无法满足，就返回NULL指针

free则接受一个由malloc、calloc或realloc返回的值，或者NULL，把分配的内存还给内存池
### 与calloc和realloc的区别
* calloc返回指针之后又初始化为0
* realloc修改已分配内存块，扩大或缩小。
## 使用
```C
int *pi;
...
pi = malloc( 100 );
if( pi == NULL ){
    printf( "Out of memory!\n");
    exit( 1 );
////////////////////////////分割线
    int i;
    ...
    for( i = 0; i < 25; i += 1 )
        pi[i] = 0;
}
```
包含了
* 对NULL指针的检查
* 下标引用
## __常见错误__
1. __对NULL指针解引用操作__ - 最常见的
2. 对分配的内存进行操作时越过边界
3. 释放并非动态分配的内存
4. 试图释放一块动态分配的内存的一部分
5. 一块动态内存被释放之后被继续使用
# 高级指针
```C
float f();
float *f();
float (*f)();
float (*f[])();
float *(*f[])();
```
# 预处理器
```C
#include
#define
#undef
#if
#endif
```
# IO函数
# 标准库
# ADT
# 运行时环境