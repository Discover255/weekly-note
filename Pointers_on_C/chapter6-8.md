# 第六章 指针
## 边界对齐问题
## 摘抄
> 通过一个指针访问它所指向的地址的过程成为间接访问或解引用指针

> 在一台运行windows的PC上，对未初始化或非法指针进行间接的访问操作时一般保护性异常。

>对那些要求整数必须存储于特定边界的机器而言，如果这种类型的数据在内存中的存储地址处在错误的边界上，那么对这个地址进行访问时将会产生一个错误。
```C
int *a;
...
*a - 12;
```
>相比赋指针为零值使其为NULL指针，一种更为安全的策略是让函数返回两个独立的值：首先是个状态值，用于提示查找是否成功；其次是个指针，当状态值提示查找成功时，它所指向的就是查找到的元素。

> *操作符具有从右向左的结核性

> 间接访问操作符是少数几个其结果为左值得操作符之一。如*(cp+1) = 123
## 指针运算
> 试想在某台机器上，float占据4个字节。在计算float型指针加3的表达式时，这个3将根据float类型的大小（此例中为4）进行调整（相乘）。

> 只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。返回的值是以数组的长度为单位

> 绝大多数编译器都不会检查指针表达式的结果是否位于合法的边界之内。因此，程序员应该负起责任，确保这一点。
# 第七章 函数
## 函数原型
>如果没有关于调用函数的特定信息，编译器会假定这个函数的调用时参数的类型和数量是正确的。它同时会假定函数将返回一个整型值。对于那些返回值并非整型的函数而言，这种隐式认定常常导致错误（返回一个float值会被解析成int）

更好的原型使用方法
```C
#include "func.h"
void
a()
{
    ...
}
void
b()
{
    ...
}
```
1. 现在函数原型具有文件作用域，所以原型的一份拷贝可以作用域整个源文件
2. 函数原型只书写一次，这样就不会出现多分拷贝之间的不匹配线性
3. 如果函数的定义进行了修改，只需修改原型，重新编译即可
4. 如果函数的原型同时也被#include包含，编译器就可以确认函数原型与定义的匹配。
## 函数参数
1. 如果是普通变量传入，那么传入的只是变量的拷贝
2. 如果是数组传入，那么是“传址调用”。
    > 数组名的值实际上是一个指针，传递给函数的就是这个指针的一份拷贝。下表引用实际上是间接访问的另一种形式。
## ADT和黑盒
C可以设计和实现抽象数据类型ADT，因为可以限制函数和数据定义的作用域。这个技巧也被称为黑盒。限制对模块的访问是通过static关键字的合理使用实现的。
## 递归
递归通过堆栈实现的，涉及一系列运行时开销：参数必须压到堆栈中，为局部变量分配内存空间，寄存器的值必须保存等。
=> 递归的性能不如迭代，但比迭代易读简洁
# 第八章 数组
