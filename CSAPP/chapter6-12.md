# 存储器层次结构
## RAM是什么，ROM又是什么
ram分为静态RAM和动态RAM，也就是SRAM和DRAM。DRAM的原理是不断地往超单元里读写数据，达到保持的效果，DRAM的存储的数据容易收到干扰丢失，而SRAM只要在通电的情况下，其存储的数据都几乎不会丢失，因此无须快速的刷新它。
> ### 超单元是什么
> ![超单元的术语解释](超单元.png)

现在最常见的是DDR SDRAM(双倍数据速率同步DRAM)。</br>
> 如果断电，RAM会丢失它们的信息，从这个意义上来说，它们是易失的。另一方面，非易失性存储器即使在关电后，也仍然保存信息。由于历史原因，虽然ROM中有的类型既可以读又可以写，但它们整体上都称为ROM。

ROM以它们重编程的次数和方式分类，分为PROM(可编程ROM，只能编程一次)->EPROM(可擦写编程ROM，在紫外光照射下擦除，max=10^3)->EEPROM(电子可擦写ROM，无须紫外光就可以擦除, max=10^5)->flash(基于EEPROM)
## 如何访问主存
答案是总线。<br>
CPU->总线->I/O桥->主存
![典型的CPU访问主存](CPU主存总线结构.png)
在Intel系统中，北桥和南桥芯片组分别连接到存储器和I/O设备。
## 磁盘如何工作
![磁盘结构](磁盘构造.png)
![磁盘方式](磁盘方式.png)
磁头在盘面上高速飞行，中间有一层薄薄的气垫。因此磁盘必须在无尘条件下工作，否则尘埃颗粒会高速撞击读写头，使读写头撞到盘面。
## 优化性能的另一种方式-局部性
### 什么是局部性
> 一个编写良好的计算机程序常常具有良好的局部性。也就是说，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理。<br>局部性通常有两种形式：
> 1. 时间局部性。被引用过一次的存储器位置可能在不远的将来再被多次引用。
> 2. 空间局部性。如果一个存储器位置被引用了一次，那么程序可能在不远的将来引用附近的一个存储器位置。
### 示例
![体现在数组](数组局部性.png)
数组的行是连续的，列之间有分隔。
## 如何编写高速缓存友好(cache friendly)的代码
尽可能地提高缓存命中率
* 对局部变量的反复引用
* 步长为1的引用模式。第一次引用未命中，缓存会一次载入一个块，因此下一次引用块内的数据速度会更快。
# 链接
## 什么是链接，为什么需要链接
> 链接是将各种代码和数据部分收集起来并组合成为单一文件的过程，这个文件可被加载（或拷贝）到存储器并执行。

链接可以执行于
1. 编译时(compile time)
2. 加载时(load time)
3. 运行时(run time)

静态链接器做了哪些，对可重定位目标文件（由不同的代码和数据节组成）
1. 符号解析。目标文件定义和引用符号。目的是将每个符号引用刚好和一个符号定义联系起来。
2. 重定位。链接器通过把每一个符号定义与一个存储器位置联系起来，然后修改对这些符号的引用，使得他们指向这个存储器位置，从而重定向这些节。
### 概念解释|什么是目标文件，什么是符号符号表，重定位如何实现
#### 目标文件(Object)
1. 可重定位目标文件。包含二进制代码和数据，可在编译时与其他可重定位目标文件合并起来，创建一个可执行文件
2. 可执行目标文件。包含二进制代码和数据，可直接执行。
3. 共享(shared)目标文件。特殊的可重定位目标文件，可在加载或运行时被动态地加载到存储器并链接

现代Unix系统使用的是Unix可执行和可链接格式，即ELF
#### 第一种可重定位目标文件
<img style="max-width:65%" src = "可重定位目标文件.png"></img>
| 节         |                    作用                    |
| :-------- | :--------------------------------------: |
| .test     |                已编译程序的机器源码                |
| .rodata   |                   只读数据                   |
| .data     |                已初始化的全局C变量                |
| .bss      |                未初始化的全局C变量                |
| .symtab   |      一个符号表。它存放着程序中定义和引用的函数和全局变量的信息       |
| .rel.test |              一个text节中位置的列表               |
| .rel.data |          被模块引用或定义的任何全局变量的重定位信息           |
| .debug    |                 一个调试符号表                  |
| .line     | 原始C程序中行号和.text节中机器指令的映射。只有以-g选项调用编译驱动程序才会得到这张表 |
| .strtab   |                  一个字符串表                  |
符号表也分为
1. 由m定义的，能被其他模块引用的全局符号。对应不带C static属性的全局变量
2. 由其他模块定义的，并被m引用的全局符号。称为external外部符号
3. 只被m定义和引用的本地符号。对应C static
#### 什么是动态链接(what)，如何使用(how)
动态链接用于解决静态链接的缺陷，包括
1. 静态库需要定期维护更新，程序员要显式地将程序与更新后的库链接
2. 库里用不着的函数也会复制到代码段，这是对存储器的浪费

共享库是致力于解决静态链接缺陷的现代创新产物。动态链接在unix上用.so(shared object)表示，在windows上用DLL(动态链接库)表示
# 异常控制流
> ### 什么是异常控制流
> a0,a1,a2... 这样的控制转移序列叫做处理器的控制流。最简单的控制流是平滑的。现代操作系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流。
## 异常处理过程的名词解释
* 异常，就是控制流中的突变
* 事件，是指状态变化
* 异常表，跳转表
## 异常与过程调用的不同点
1. 处理器把额外的信息压入栈中
2. 异常处理程序运行于内核模式下

![区别](异常与过程调用的区别.png)
## 异常的类别
* 中断
* 陷阱
* 故障
* 终止

| 类别   | 原因         | 异步/同步 | 返回行为       |
| :--- | :--------- | :---- | :--------- |
| 中断   | 来自I/O设备的信号 | 异步    | 总是返回到下一条指令 |
| 陷阱   | 有意的异常      | 同步    | 总是返回下一条指令  |
| 故障   | 潜在可恢复的错误   | 同步    | 可能返回到当前指令  |
| 终止   | 不可恢复的错误    | 同步    | 不会返回       |

中断时异步的。硬件中断的异常处理程序通常称为中断处理程序。剩下的异常类型是同步的，是执行当前指令的结果。我们把这类指令叫做故障指令。

陷阱最重要的用途是提供用户程序和内核之间的一个像过程一样的接口。它与普通函数调用的区别是，普通函数只能运行在用户模式下，访问与调用函数相同的栈，系统调用运行在内核模式中，访问定义在内核中的栈。
## Unix中如何操作进程
使用PID，每个进程都有自己的PID。Unix C语言通过fork创建进程。子进程的空间是父进程的拷贝。进程有三种状态。fork函数返回两次，子进程拿到的是0，父进程拿到的是pid
## 非本地化跳转
这种跳转是用setjmp和longjmp实现的，它可以在捕捉到信号(SIGNAL)，并作出跳转。与goto有很大的不同。
# 虚拟存储器
现代处理器都使用虚拟寻址，而很多嵌入式处理器使用物理寻址。理解虚拟寻址很重要。地址空间与处理器位数有关，2^M，M为处理器位数
# 系统级I/O
为什么要学习系统级I/O,许多编程语言已经提供了高级别的I/O函数
1. 帮助了解系统
2. 有时只能使用系统级I/O,包括
    * 标准I/O库没有读取文件元数据的方式
    * I/O库存在一些问题,使得用它进行网络编程十分冒险
## UNIX I/O概述
在Unix中,一切皆文件.Unix中一切文件都是m个字节地序列,所有I/O设备都被模型化成一个个文件,所有的I和O都被当成对应的文件的读和写,这种优雅地映射为文件的方式,使得所有的I和O都能以一种统一且一致的方式来执行:
1. 打开文件
2. 改变当前文件的位置
3. 读写文件
4. 关闭文件
## 打开和关闭文件
```C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcnt1.h>
int open(char *filename, int flags, mode_t mode);//open函数的原型
```
flags表示要执行的操作,mode表示新文件的权限,它们都可以是多个参数的或
![访问权限位](访问权限位.png)
* O_RDONLY 只读
* O_WRONLY 只写
* O_RDWR 可读可写
* O_CREAT 不存在则创建截短的(truncated)空白文件
* O_TRUNC 已存在则覆盖成空白文件
* O_APPEND 每次写操作前,设置文件位置到末尾处
```C
#define DEF_MODE ...
#define DEF_UMASK ...
umask(DEF_UMASK);//通过umask函数设置当前进程的权限
fd = Open("foo.txt", O_CREAT|O_TRUNC|O_WRONGLY, DEF_MODE);
//fd是open函数返回的描述码
```
```C
#include <unistd.h>
int close(int fd);//close的原型,fd是描述码
```

# 网络编程

## 客户端-服务器编程模型

这个模型最重要的事务,客户端向服务器提出一个请求,服务器代表客户端执行读取磁盘或者其他的操作,返回一个响应,并等待下一个请求

### 套接字接口(socket interface)

使用套接字常常是在操作操作系统自身的API/文件.套接字分为客户端和服务器使用的